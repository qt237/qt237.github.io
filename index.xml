<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>qt237的code记录 on qt237的博客</title>
    <link>https://qt237.github.io/</link>
    <description>Recent content in qt237的code记录 on qt237的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://qt237.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python的测试</title>
      <link>https://qt237.github.io/language/python08/</link>
      <pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python08/</guid>
      <description>测试用实例代码 name_function.py
def get_formatted_name(first, last, middle=&amp;#34;&amp;#34;): &amp;#39;&amp;#39;&amp;#39;生成整洁的姓名&amp;#39;&amp;#39;&amp;#39; if middle: full_name = f&amp;#34;{first}{middle}{last}&amp;#34; else: full_name = f&amp;#34;{first}{last}&amp;#34; return full_name.title() names.py
from name_function import get_formatted_name print(&amp;#34;Enter &amp;#39;q&amp;#39; at any time to quit.&amp;#34;) while True: first = input(&amp;#34;\nplease give me a first name:&amp;#34;) if first == &amp;#39;q&amp;#39;: break last = input(&amp;#34;please give me a last name:&amp;#34;) if last == &amp;#39;q&amp;#39;: break format_name = get_formatted_name(first, last) print(f&amp;#34;\tNeatly formatted name: {format_name}.&amp;#34;) 测试 Python标准库中的模块unittest 提供了代码测试工具。单元测试 用于核实函数的某个方面没有问题。测试用例 是一组单元测试，它们一道核实函数在各种情形下的行为都符合要求。良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。全覆盖 的测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要进行全覆盖测试可能很难。</description>
    </item>
    
    <item>
      <title>python的文件读取和异常</title>
      <link>https://qt237.github.io/language/python07/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python07/</guid>
      <description>读取文件 我们创建一个test.txt，然后读取。
with open(&amp;#34;test.txt&amp;#34;) as file_object: contents = file_object.read() print(contents) 要想读取任何一个文件，都需要先打开文件，才能访问它。open()返回一个表示文件text.txt的对象，python把对象赋值给file_object。在C里文件打开后，使用完成要关闭，不然会出现异常。python用上述结构，python会帮你关闭。
注意相对路径和绝对路径的问题。
open有两个参数，第二个可以指定以哪种模式打开。如果省略就是默认的只读模式。
注意，with结构open返回的文件对象只在with代码块内可以使用，要在代码块外访问文件的内容，可以在with代码块内将文件的各行存储在一个列表里，在代码块外使用该列表。上文content也是一样的。
with open(&amp;#34;test.txt&amp;#34;) as file_object: lines = file_object.readlines() for line in lines: print(line.rstrip()) 写入文件 open有两个参数，第二个可以指定以哪种模式打开。
   参数 模式     r 读   w 写   a 附加   r+ 读写    w 在写入的时候，如果文件不存在，会创建文件。
filename = &amp;#34;test.txt&amp;#34; with open(filename, &amp;#34;w&amp;#34;) as file_object: file_object.write(&amp;#34;Hello World!&amp;#34;) 注意： python只能将字符串写入文本文件，要将数值存储到txt文件里，必须要用函数str()，转换成字符串。
写入多行的时候记得加换行符\n
写入会覆盖源文件的内容。如果想要在后面附加内容，保留源文件的内容，那么选择以附加模式打开文件。</description>
    </item>
    
    <item>
      <title>python的类</title>
      <link>https://qt237.github.io/language/python06/</link>
      <pubDate>Sat, 17 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python06/</guid>
      <description>python的类 方法__init__() __init()__是一个特殊的类中的函数。每当根据类来创建实体的时候，Python都会自动调用它来完成构建。在此函数里，形参self 必不可少，而且必须位于其他形参的前面。如：
class Dog: &amp;#34;&amp;#34;&amp;#34;一次模拟小狗的简单尝试。&amp;#34;&amp;#34;&amp;#34; def __init__(self, name, age): &amp;#34;&amp;#34;&amp;#34;初始化属性name和age。&amp;#34;&amp;#34;&amp;#34; self.name = name self.age = age self.color = &amp;#34;write&amp;#34; def sit(self): &amp;#34;&amp;#34;&amp;#34;模拟小狗收到命令时蹲下。&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;{self.name}is now sitting.&amp;#34;) def roll_over(self): &amp;#34;&amp;#34;&amp;#34;模拟小狗收到命令时打滚。&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;{self.name}rolled over!&amp;#34;) 生成一个实例mydog：
mydog = Dog(name=&amp;#34;tom&amp;#34;, age=6) print(f&amp;#34;My dog&amp;#39;s name is {mydog.name}.&amp;#34;) my_dog.sit() my_dog.roll_over() 创建实例时，有些属性无须通过形参来定义，可在方法__init__() 中为其指定默认值。
类的继承 在既有类的基础上编写新类时，通常要调用父类的方法__init__() 。这将初始化在父类__init__() 方法中定义的所有属性，从而让子类包含这些属性。
父类Car：
class Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_description_name(self): long_name = f&amp;#34;{self.</description>
    </item>
    
    <item>
      <title>python的函数</title>
      <link>https://qt237.github.io/language/python05/</link>
      <pubDate>Fri, 16 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python05/</guid>
      <description>python的函数 def greet_user(username): &amp;#34;&amp;#34;&amp;#34;显示简单的问候语。&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;Hello, {username.title()}!&amp;#34;) greet_user(&amp;#34;tom&amp;#34;) greet_user(username=&amp;#34;linda&amp;#34;) def describe_pet(pet_name, animal_type=&amp;#39;dog&amp;#39;): &amp;#34;&amp;#34;&amp;#34;显示宠物的信息。&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;\nI have a {animal_type}.&amp;#34;) print(f&amp;#34;My {animal_type}&amp;#39;s name is {pet_name.title()}.&amp;#34;) describe_pet(pet_name=&amp;#39;willie&amp;#39;) 传递任意数量的实参 def make_pizza(size, *toppings): &amp;#34;&amp;#34;&amp;#34;概述要制作的比萨。&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;\nMaking a {size}-inch pizza with the following toppings:&amp;#34;) for topping in toppings: print(f&amp;#34;- {topping}&amp;#34;) make_pizza(16, &amp;#39;pepperoni&amp;#39;) make_pizza(12, &amp;#39;mushrooms&amp;#39;, &amp;#39;green peppers&amp;#39;, &amp;#39;extra cheese&amp;#39;) 注意*toopings放在最后。
使用任意数量的关键字实参 有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调用语句提供了多少就接受多少。
def build_profile(first, last, **user_info): &amp;#34;&amp;#34;&amp;#34;创建一个字典，其中包含我们知道的有关用户的一切。&amp;#34;&amp;#34;&amp;#34; user_info[&amp;#39;first_name&amp;#39;] = first user_info[&amp;#39;last_name&amp;#39;] = last return user_info user_profile = build_profile(&amp;#39;albert&amp;#39;, &amp;#39;einstein&amp;#39;, location=&amp;#39;princeton&amp;#39;, field=&amp;#39;physics&amp;#39;) print(user_profile) &amp;#34;&amp;#34;&amp;#34; 输出： {&amp;#39;location&amp;#39;: &amp;#39;princeton&amp;#39;, &amp;#39;field&amp;#39;: &amp;#39;physics&amp;#39;, &amp;#39;first_name&amp;#39;: &amp;#39;albert&amp;#39;, &amp;#39;last_name&amp;#39;: &amp;#39;einstein&amp;#39;} &amp;#34;&amp;#34;&amp;#34; 形参**user_info 中的两个星号让Python创建一个名为user_info 的空字典，并将收到的所有名称值对都放到这个字典中。</description>
    </item>
    
    <item>
      <title>python的字典</title>
      <link>https://qt237.github.io/language/python04/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python04/</guid>
      <description>字典 字典是一系列的键值对，每个键值对是一个键和与键对应关联的值，可以通过访问键的形式来返回键对应的值。字典用{}来表示。
alien = {} # 创建空字典 alien_0 = {&amp;#39;color&amp;#39;: &amp;#39;green&amp;#39;, &amp;#39;points&amp;#39;: 5} #创建非空字典 print(alien_0[&amp;#39;color&amp;#39;]) # 返回green alien_0[&amp;#39;x_position&amp;#39;] = 0 # 添加键值对 删除字典的键值对：
del alien_0[&amp;#39;x_position&amp;#39;] 删除后值会永远消失，注意。
使用get()来访问值 对比直接调用的好处是可以设置错误返回值，这样的话当不存在键值对和值等情况可以更好应对。
alien_0 = {&amp;#39;color&amp;#39;: &amp;#39;green&amp;#39;, &amp;#39;speed&amp;#39;: &amp;#39;slow&amp;#39;} print(alien_0[&amp;#39;points&amp;#39;]) # 输出错误显示 KeyError: &amp;#39;points&amp;#39; 因为不存在points，所以报错了，程序不会正常启动。这种情况下，可以使用get()。
方法get() 的第一个参数用于指定键，是必不可少的；第二个参数为指定的键不存在时要返回的值，是可选的，在不填的情况下默认返回None。在下文里会返回指定的参数：No point value assigned。
alien_0 = {&amp;#39;color&amp;#39;: &amp;#39;green&amp;#39;, &amp;#39;speed&amp;#39;: &amp;#39;slow&amp;#39;} point_value = alien_0.get(&amp;#39;points&amp;#39;, &amp;#39;No point value assigned.&amp;#39;) print(point_value) 遍历字典 for循环来遍历字典里所有的键和值。
user_0 = { &amp;#39;username&amp;#39;: &amp;#39;efermi&amp;#39;, &amp;#39;first&amp;#39;: &amp;#39;enrico&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;fermi&amp;#39;, } for key, value in user_0.</description>
    </item>
    
    <item>
      <title>python的if,and,or</title>
      <link>https://qt237.github.io/language/python03/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python03/</guid>
      <description>if 一个简单的实例：
cars = [&amp;#39;audi&amp;#39;, &amp;#39;bmw&amp;#39;, &amp;#39;subaru&amp;#39;, &amp;#39;toyota&amp;#39;] for car in cars: if car == &amp;#39;bmw&amp;#39;: print(car.upper()) elif car == &amp;#39;audi&amp;#39; print(car.lower()) else: print(car.title()) 判断条件 a == b #等于 a != b #不等于 a &amp;gt; b a &amp;lt; b a &amp;gt;= b a &amp;lt;= b (a &amp;gt; b) and (a = b) #与 (a &amp;gt; b) or (a = b) #或 cat in cats #返回True/False cat not in cats #返回True/False if cats #判断是不是空的列表 大概这样的，和C差不多不过有点区别。</description>
    </item>
    
    <item>
      <title>python的元祖</title>
      <link>https://qt237.github.io/language/python02/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python02/</guid>
      <description>python的元祖 元组看起来很像列表，但使用圆括号而非中括号来标识。定义元组后，就可使用索引来访问其元素，就像访问列表元素一样。
例如，如果有一个大小不应改变的矩形，可将其长度和宽度存储在一个元组中，从而确保它们是不能修改的。
dimensions = (200, 50) print(dimensions[0]) print(dimensions[1]) 如果要定义只包含一个元素的元组，必须在这个元素后面加上逗号:
my_t = (3,) 也可以像列表一样遍历，修改其中的具体的值。
dem = (200, 500) print(dem) dem = (100, 300) print(dem) 除了不能改变大小和列表是一样的。</description>
    </item>
    
    <item>
      <title>python的列表 list</title>
      <link>https://qt237.github.io/language/python01/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://qt237.github.io/language/python01/</guid>
      <description>python的列表 list 列表我觉得是python里自己的很独特的一个数据结构。生成也很简单。应该空的列表。list = []很简单。python不像C++那样指定变量的类型。变量的定义和赋值都非常简单。列表也是一样的。
list = [] list1 = [1,2,3] list2 = [&amp;#39;hello&amp;#39;,&amp;#39;world&amp;#39;] 很适合处理字符。
关于列表的遍历，一个for循环就可以了。直接print列表的话，得到的是[&#39;hello&#39;,&#39;world&#39;]这样代[]的数据，遍历的话可以这样：
lists = [&amp;#39;hello&amp;#39;,&amp;#39;world&amp;#39;] for list in lists: print(list) 列表的一部分：切片 要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range() 一样，Python在到达第二个索引之前的元素后停止。要输出列表中的前三个元素，需要指定索引0和3，这将返回索引为0、1和2的元素。
players = [&amp;#39;charles&amp;#39;, &amp;#39;martina&amp;#39;, &amp;#39;michael&amp;#39;, &amp;#39;florence&amp;#39;, &amp;#39;eli&amp;#39;] print(players[0:3]) players[:3]：从0开始到第三个元素结束。
players[-3:]：后三个元素
players[:]：遍历整个切片
关于赋值的一些问题 my_foods = [&amp;#39;pizza&amp;#39;, &amp;#39;falafel&amp;#39;, &amp;#39;carrot cake&amp;#39;] # 这行不通: friend_foods = my_foods my_foods.append(&amp;#39;cannoli&amp;#39;) friend_foods.append(&amp;#39;ice cream&amp;#39;) print(&amp;#34;My favorite foods are:&amp;#34;) print(my_foods) print(&amp;#34;\nMy friend&amp;#39;s favorite foods are:&amp;#34;) print(friend_foods) 得到两个一样的输出。这个时候想达到效果用切片：
friend_foods = my_foods[:] my_foods.append(&amp;#39;cannoli&amp;#39;) friend_foods.append(&amp;#39;ice cream&amp;#39;) print(&amp;#34;My favorite foods are:&amp;#34;) print(my_foods) print(&amp;#34;\nMy friend&amp;#39;s favorite foods are:&amp;#34;) print(friend_foods) 切片的一种用法。</description>
    </item>
    
    <item>
      <title>test post</title>
      <link>https://qt237.github.io/base/test/</link>
      <pubDate>Sun, 11 Feb 2024 18:02:38 +0800</pubDate>
      
      <guid>https://qt237.github.io/base/test/</guid>
      <description>Hello World hello world
你好世界</description>
    </item>
    
    <item>
      <title>test post</title>
      <link>https://qt237.github.io/object/test/</link>
      <pubDate>Sun, 11 Feb 2024 18:02:38 +0800</pubDate>
      
      <guid>https://qt237.github.io/object/test/</guid>
      <description>Hello World hello world
你好世界</description>
    </item>
    
  </channel>
</rss>
